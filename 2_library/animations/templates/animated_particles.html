<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Universe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }

        .content {
            position: relative;
            z-index: 10;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            text-align: center;
            pointer-events: none;
        }

        .hero {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }

        .title {
            font-size: clamp(3rem, 10vw, 8rem);
            font-weight: 100;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s ease-in-out infinite alternate;
            margin-bottom: 1rem;
        }

        @keyframes titleGlow {
            from {
                filter: drop-shadow(0 0 20px rgba(102, 126, 234, 0.5));
            }
            to {
                filter: drop-shadow(0 0 40px rgba(240, 147, 251, 0.8));
            }
        }

        .subtitle {
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 300;
            letter-spacing: 0.3em;
            color: rgba(255, 255, 255, 0.6);
            animation: fadeInUp 2s ease-out 0.5s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .scroll-indicator {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s ease-in-out infinite;
        }

        .scroll-indicator::before {
            content: '';
            display: block;
            width: 30px;
            height: 50px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            position: relative;
        }

        .scroll-indicator::after {
            content: '';
            display: block;
            width: 6px;
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 3px;
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            animation: scrollDot 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(10px); }
        }

        @keyframes scrollDot {
            0%, 100% { opacity: 1; top: 10px; }
            50% { opacity: 0.3; top: 25px; }
        }

        .section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 4rem 2rem;
        }

        .section-title {
            font-size: clamp(2rem, 6vw, 4rem);
            font-weight: 200;
            margin-bottom: 2rem;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section-text {
            max-width: 600px;
            font-size: 1.2rem;
            line-height: 2;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            max-width: 1000px;
            margin-top: 3rem;
            pointer-events: auto;
        }

        .feature-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 2rem;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: default;
        }

        .feature-card:hover {
            transform: translateY(-10px) scale(1.02);
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(102, 126, 234, 0.5);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.2);
        }

        .feature-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .feature-title {
            font-size: 1.3rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #fff;
        }

        .feature-desc {
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
        }

        .cta-section {
            min-height: 50vh;
        }

        .cta-button {
            pointer-events: auto;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: #fff;
            padding: 1rem 3rem;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-top: 2rem;
        }

        .cta-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.4);
        }

        .footer {
            padding: 2rem;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>

    <div class="content">
        <section class="hero">
            <h1 class="title">Cosmos</h1>
            <p class="subtitle">Interactive Particle Universe</p>
            <div class="scroll-indicator"></div>
        </section>

        <section class="section">
            <h2 class="section-title">Explore the Universe</h2>
            <p class="section-text">
                Move your cursor across the screen to interact with thousands of particles.
                Watch as they dance, flow, and respond to your every movement.
            </p>
            <div class="features">
                <div class="feature-card">
                    <div class="feature-icon">&#10024;</div>
                    <h3 class="feature-title">Particle Physics</h3>
                    <p class="feature-desc">Real-time physics simulation with velocity, acceleration, and natural decay.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">&#127752;</div>
                    <h3 class="feature-title">Fluid Motion</h3>
                    <p class="feature-desc">Smooth, organic movement patterns that mimic natural fluid dynamics.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">&#128171;</div>
                    <h3 class="feature-title">Mouse Interaction</h3>
                    <p class="feature-desc">Particles respond to your cursor with attraction and repulsion forces.</p>
                </div>
            </div>
        </section>

        <section class="section cta-section">
            <h2 class="section-title">Experience the Magic</h2>
            <p class="section-text">
                Built with pure Canvas API. No external libraries.
                Optimized for performance with thousands of particles.
            </p>
            <button class="cta-button" onclick="toggleMode()">Change Mode</button>
        </section>

        <footer class="footer">
            <p>Crafted with Canvas API</p>
        </footer>
    </div>

    <script>
        // Canvas Setup
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        // Mouse tracking
        const mouse = {
            x: width / 2,
            y: height / 2,
            radius: 150,
            isActive: false
        };

        // Particle modes
        let currentMode = 0;
        const modes = ['starfield', 'fluid', 'galaxy', 'aurora'];

        // Color palettes for each mode
        const palettes = {
            starfield: ['#ffffff', '#fffef0', '#f0f8ff', '#e6e6fa', '#fff5ee'],
            fluid: ['#667eea', '#764ba2', '#f093fb', '#00d2ff', '#3a7bd5'],
            galaxy: ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff'],
            aurora: ['#00ff87', '#60efff', '#ff00ff', '#00ffff', '#ff6b6b']
        };

        // Particle class
        class Particle {
            constructor(isBackground = false) {
                this.isBackground = isBackground;
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = this.isBackground ? Math.random() * 2 + 0.5 : Math.random() * 4 + 1;
                this.speedX = (Math.random() - 0.5) * 2;
                this.speedY = (Math.random() - 0.5) * 2;
                this.life = 1;
                this.decay = Math.random() * 0.005 + 0.002;

                const palette = palettes[modes[currentMode]];
                this.color = palette[Math.floor(Math.random() * palette.length)];
                this.originalSize = this.size;

                // For fluid mode
                this.angle = Math.random() * Math.PI * 2;
                this.angularSpeed = (Math.random() - 0.5) * 0.02;

                // For aurora mode
                this.waveOffset = Math.random() * Math.PI * 2;
                this.waveSpeed = Math.random() * 0.02 + 0.01;
            }

            update() {
                const mode = modes[currentMode];

                switch(mode) {
                    case 'starfield':
                        this.updateStarfield();
                        break;
                    case 'fluid':
                        this.updateFluid();
                        break;
                    case 'galaxy':
                        this.updateGalaxy();
                        break;
                    case 'aurora':
                        this.updateAurora();
                        break;
                }

                // Mouse interaction
                if (mouse.isActive && !this.isBackground) {
                    const dx = mouse.x - this.x;
                    const dy = mouse.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < mouse.radius) {
                        const force = (mouse.radius - distance) / mouse.radius;
                        const angle = Math.atan2(dy, dx);

                        // Attraction with slight orbit
                        this.speedX += Math.cos(angle + Math.PI / 4) * force * 0.5;
                        this.speedY += Math.sin(angle + Math.PI / 4) * force * 0.5;

                        // Size pulse near mouse
                        this.size = this.originalSize * (1 + force * 0.5);
                    }
                }

                // Apply friction
                this.speedX *= 0.98;
                this.speedY *= 0.98;

                // Update position
                this.x += this.speedX;
                this.y += this.speedY;

                // Life decay for non-background particles
                if (!this.isBackground) {
                    this.life -= this.decay;
                    if (this.life <= 0) {
                        this.reset();
                    }
                }

                // Wrap around screen
                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;
            }

            updateStarfield() {
                // Twinkling effect
                this.life = 0.5 + Math.sin(Date.now() * 0.005 + this.waveOffset) * 0.5;

                // Slow drift
                this.speedX += (Math.random() - 0.5) * 0.01;
                this.speedY += (Math.random() - 0.5) * 0.01;
            }

            updateFluid() {
                // Perlin-like noise movement
                this.angle += this.angularSpeed;
                this.speedX += Math.cos(this.angle) * 0.1;
                this.speedY += Math.sin(this.angle) * 0.1;

                // Add some turbulence
                const turbulence = Math.sin(this.x * 0.01 + Date.now() * 0.001) * 0.1;
                this.speedY += turbulence;
            }

            updateGalaxy() {
                // Spiral movement around center
                const centerX = width / 2;
                const centerY = height / 2;
                const dx = this.x - centerX;
                const dy = this.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                // Orbital velocity (faster near center)
                const orbitalSpeed = 0.001 + (500 / (distance + 100)) * 0.0005;

                this.x = centerX + Math.cos(angle + orbitalSpeed) * distance;
                this.y = centerY + Math.sin(angle + orbitalSpeed) * distance;

                // Slight inward drift
                this.x += (centerX - this.x) * 0.0001;
                this.y += (centerY - this.y) * 0.0001;
            }

            updateAurora() {
                // Wave-like vertical movement
                this.waveOffset += this.waveSpeed;
                this.speedY = Math.sin(this.waveOffset) * 0.5;
                this.speedX = Math.cos(this.waveOffset * 0.5) * 0.3;

                // Upward drift
                this.y -= 0.5;
                if (this.y < -10) {
                    this.y = height + 10;
                    this.x = Math.random() * width;
                }
            }

            draw() {
                ctx.save();

                const alpha = this.isBackground ? 0.3 + Math.random() * 0.2 : this.life;

                // Create gradient for glow effect
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 2
                );

                const colorWithAlpha = this.hexToRgba(this.color, alpha);
                const colorTransparent = this.hexToRgba(this.color, 0);

                gradient.addColorStop(0, colorWithAlpha);
                gradient.addColorStop(0.4, this.hexToRgba(this.color, alpha * 0.5));
                gradient.addColorStop(1, colorTransparent);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = colorWithAlpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
        }

        // Connection lines class
        class ConnectionManager {
            constructor() {
                this.maxDistance = 100;
            }

            draw(particles) {
                if (modes[currentMode] !== 'fluid' && modes[currentMode] !== 'galaxy') return;

                ctx.save();

                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < this.maxDistance) {
                            const alpha = (1 - distance / this.maxDistance) * 0.2;
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.stroke();
                        }
                    }
                }

                ctx.restore();
            }
        }

        // Shooting star class
        class ShootingStar {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height * 0.5;
                this.length = Math.random() * 80 + 40;
                this.speed = Math.random() * 15 + 10;
                this.angle = Math.PI / 4 + (Math.random() - 0.5) * 0.5;
                this.opacity = 1;
                this.active = false;
                this.trail = [];
            }

            activate() {
                if (!this.active && Math.random() < 0.002) {
                    this.active = true;
                    this.x = Math.random() * width;
                    this.y = Math.random() * height * 0.3;
                    this.opacity = 1;
                    this.trail = [];
                }
            }

            update() {
                if (!this.active) {
                    this.activate();
                    return;
                }

                this.trail.unshift({ x: this.x, y: this.y, opacity: this.opacity });
                if (this.trail.length > 20) this.trail.pop();

                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.opacity -= 0.02;

                if (this.opacity <= 0 || this.x > width || this.y > height) {
                    this.reset();
                }
            }

            draw() {
                if (!this.active) return;

                ctx.save();

                // Draw trail
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    const alpha = (1 - i / this.trail.length) * point.opacity * 0.8;
                    const size = (1 - i / this.trail.length) * 3;

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw head
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, 5
                );
                gradient.addColorStop(0, `rgba(255, 255, 255, ${this.opacity})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Particle spawner for mouse trail
        class MouseTrail {
            constructor() {
                this.particles = [];
                this.maxParticles = 50;
            }

            spawn() {
                if (!mouse.isActive) return;

                if (this.particles.length < this.maxParticles) {
                    const palette = palettes[modes[currentMode]];
                    this.particles.push({
                        x: mouse.x + (Math.random() - 0.5) * 20,
                        y: mouse.y + (Math.random() - 0.5) * 20,
                        size: Math.random() * 3 + 2,
                        speedX: (Math.random() - 0.5) * 4,
                        speedY: (Math.random() - 0.5) * 4,
                        life: 1,
                        color: palette[Math.floor(Math.random() * palette.length)]
                    });
                }
            }

            update() {
                this.spawn();

                this.particles = this.particles.filter(p => {
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.speedX *= 0.95;
                    p.speedY *= 0.95;
                    p.life -= 0.02;
                    p.size *= 0.98;
                    return p.life > 0;
                });
            }

            draw() {
                ctx.save();

                this.particles.forEach(p => {
                    const gradient = ctx.createRadialGradient(
                        p.x, p.y, 0,
                        p.x, p.y, p.size * 2
                    );

                    const r = parseInt(p.color.slice(1, 3), 16);
                    const g = parseInt(p.color.slice(3, 5), 16);
                    const b = parseInt(p.color.slice(5, 7), 16);

                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${p.life})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.restore();
            }
        }

        // Initialize particles
        const backgroundStars = [];
        const particles = [];
        const shootingStars = [];
        const connectionManager = new ConnectionManager();
        const mouseTrail = new MouseTrail();

        const BACKGROUND_COUNT = 200;
        const PARTICLE_COUNT = 150;
        const SHOOTING_STAR_COUNT = 3;

        function init() {
            // Background stars (always visible)
            for (let i = 0; i < BACKGROUND_COUNT; i++) {
                backgroundStars.push(new Particle(true));
            }

            // Interactive particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle(false));
            }

            // Shooting stars
            for (let i = 0; i < SHOOTING_STAR_COUNT; i++) {
                shootingStars.push(new ShootingStar());
            }
        }

        // Animation loop
        function animate() {
            // Create trailing effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Update and draw background stars
            backgroundStars.forEach(star => {
                star.update();
                star.draw();
            });

            // Update and draw shooting stars
            shootingStars.forEach(star => {
                star.update();
                star.draw();
            });

            // Draw connections
            connectionManager.draw(particles.slice(0, 50));

            // Update and draw particles
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            // Mouse trail
            mouseTrail.update();
            mouseTrail.draw();

            requestAnimationFrame(animate);
        }

        // Event listeners
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.isActive = true;
        });

        window.addEventListener('mouseleave', () => {
            mouse.isActive = false;
        });

        window.addEventListener('touchmove', (e) => {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
            mouse.isActive = true;
        });

        window.addEventListener('touchend', () => {
            mouse.isActive = false;
        });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        // Mode toggle
        function toggleMode() {
            currentMode = (currentMode + 1) % modes.length;

            // Reset particles with new colors
            particles.forEach(p => {
                const palette = palettes[modes[currentMode]];
                p.color = palette[Math.floor(Math.random() * palette.length)];
            });

            // Flash effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, width, height);
        }

        // Initialize and start
        init();
        animate();
    </script>
</body>
</html>
